Какого типа команда cd? данная команда являеться встроенной в оболочку.

Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.

встроенная команда может влиять на внутреннее состояние оболочки, поэтому такия команда должна быть встроенной, 
потому что внешняя программа не может изменить текущий каталог оболочки.

Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l? man grep поможет в ответе на этот вопрос. 
я попробовал проделать данную коснтрукцию вот так 
взял файлик из прошлого задания nano 110100.md  наполнил его произвольным содержимым и попробовал данной коснтрукцией выполнить поиск
 grep f *.md | wc -l
 
 результат получился таким 
 17 строк совпадений с буковой ф
 анализируя возможные варианты без pipe 
 попробовал вот такой
 grep f 110100.md  -c
 результат аналогичный
 17 строк.
 
Ознакомьтесь с документом о других подобных некорректных вариантах использования pipe.

честно говоря это не совсем понял :(.

Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

systemd(1)─┬─VBoxService(764)─┬─{VBoxService}(765)
           │                  ├─{VBoxService}(766)
           │                  ├─{VBoxService}(767)
           │                  ├─{VBoxService}(768)
           │                  ├─{VBoxService}(769)
           │                  ├─{VBoxService}(770)
           │                  ├─{VBoxService}(771)
           │                  └─{VBoxService}(772)
           ├─accounts-daemon(560)─┬─{accounts-daemon}(617)
           │                      └─{accounts-daemon}(690)

Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?

например вот так
Вызов из pts/0
ls -l \test_bash 2>/dev/pts/1

Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.

cat <test_bash >test_bash_out

Получится ли находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?

если я правильно понял, то получиться, перенаправив, для этого у меня есть еще одна виртуальная машина ubuntu, в ней я открыл два разных терминала и из одного
терминала сделал
echo Hello from pts3 to pts0 >/dev/pts/0
переключившись смог увидеть
Hello from pts3 to pts0
приложил два скриншота.

Выполните команду bash 5>&1. К чему она приведет? Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?

bash 5>&1 - Создаст дескриптор с 5 и перенатправит его в stdout
echo netology > /proc/$$/fd/5 - выведет в дескриптор "5", который был пернеаправлен в stdout

Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? 
Напоминаем: по умолчанию через pipe передается только stdout команды слева от | на stdin команды справа. Это можно сделать, 
поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.

ls -l /root 5>&2 2>&1 1>&5 |grep denied -

5>&2 новый дискриптор перенаправили в стандартный поток ошибок
2>&1 стандартный поток ошибок перенаправили в поток вывода
1>&5 поток вывода перенаправили в новый дискриптор

Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?
выдает переменные окружения
еще помжно посмотреть env

Используя man, опишите что доступно по адресам /proc/<PID>/cmdline, /proc/<PID>/exe.
 /proc/<PID>/cmdline получим путь до исполняемого процесса.
 /proc/<PID>/exe получим путь до файла запущенного процессом
  
 Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo.
  
  sse4_2

  
При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. Это можно подтвердить командой tty, которая упоминалась в лекции 3.2. Однако:

vagrant@netology1:~$ ssh localhost 'tty'
not a tty
Почитайте, почему так происходит, и как изменить поведение.
  
По умолчанию, когда запускаем команду на удаленном компьютере с помощью ssh, 
TTY не выделяется для удаленного сеанса. 

 Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr.
  Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.

  процесс перехвачиваеться в screen, и продолжает работу после закрытия терминала. 
  
  sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, 
  так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. 
  Для решения данной проблемы можно использовать конструкцию echo string | sudo tee /root/new_file. 
  Узнайте что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.
  
  команда tee делает вывод одновременно и в файл, и в stdout, из stdin, команда запущена от sudo , т.е. имеет права на запись в файл
  


