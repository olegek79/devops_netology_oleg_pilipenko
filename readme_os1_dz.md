Какой системный вызов делает команда cd? В прошлом ДЗ мы выяснили, что cd не является самостоятельной программой, 
это shell builtin, поэтому запустить strace непосредственно на cd не получится. Тем не менее, вы можете запустить 
strace на /bin/bash -c 'cd /tmp'. В этом случае вы увидите полный список системных вызовов, которые делает сам bash при старте. 
Вам нужно найти тот единственный, который относится именно к cd.

CD -> chdir("/tmp")

Попробуйте использовать команду file на объекты разных типов на файловой системе. Например:
vagrant@netology1:~$ file /dev/tty
/dev/tty: character special (5/0)
vagrant@netology1:~$ file /dev/sda
/dev/sda: block special (8/0)
vagrant@netology1:~$ file /bin/bash
/bin/bash: ELF 64-bit LSB shared object, x86-64
Используя strace выясните, где находится база данных file на основании которой она делает свои догадки.

openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3

Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), 
однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. 
Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. 
Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла 
(чтобы освободить место на файловой системе).

что я попробовал, в очередной раз, установил nginx sudo apt install nginx
далее зашел в дректорию где лежат его логи, cd /var/log/nginx
удаляю sudo rm access.log
пробую найти по удаленному файлу и процессу ps aux -P | grep nginx | grep access.log пробовал разные комбинации, все время вовращает пустую строку
далее если бы вернулось,  то как в лекции cat /proc/181248/fd/3 > /var/log/nginx/access.log только пиды мои с nginx.


в теории я понял что необходимо сделать и в чем смысл, но на практике проделать я не смог, смыл такой что 
у нас какой то процесс работает с файлом, но файл мы удилии, нам как я понял из леции узнать PID процесса, вот я это и не смог сделать
возвращает пустую строку, на пример я открыл файл чего то там сделал в nano, потом закрыл и удалил, наверное вот это что то там ине правильно
я делаю, файл тут же отпускаеться, я не понял как сделать что бы он был удален, но удерживался при этом. ну так вот мы узнаем PID процесса
что собственно удерживает файл, после чего по PID  и названию отыскиваем его и восстанавливаем.
lsof -p 181248 | grep do_not_delete_me 

Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?
Ответ:
"Зомби" в отличии от "сирот" освобождают свои ресурсы, но не освобождают запись в таблице процессов. 

В iovisor BCC есть утилита opensnoop:
root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
/usr/sbin/opensnoop-bpfcc
На какие файлы вы увидели вызовы группы open за первую секунду работы утилиты? 
Воспользуйтесь пакетом bpfcc-tools для Ubuntu 20.04. Дополнительные сведения по установке.

переделал root@vagrant:~# /usr/sbin/opensnoop-bpfcc
PID    COMM               FD ERR PATH
376    systemd-udevd      14   0 /sys/fs/cgroup/unified/system.slice/systemd-udevd.service/cgroup.procs
376    systemd-udevd      14   0 /sys/fs/cgroup/unified/system.slice/systemd-udevd.service/cgroup.threads
763    vminfo              4   0 /var/run/utmp
562    dbus-daemon        -1   2 /usr/local/share/dbus-1/system-services
562    dbus-daemon        18   0 /usr/share/dbus-1/system-services
562    dbus-daemon        -1   2 /lib/dbus-1/system-services
562    dbus-daemon        18   0 /var/lib/snapd/dbus-1/system-services/

как я не пытался и под root  в том числе результат был таков
/usr/sbin/opensnoop-bpfcc

Какой системный вызов использует uname -a? Приведите цитату из man по этому системному вызову, 
где описывается альтернативное местоположение в /proc, 
где можно узнать версию ядра и релиз ОС.

Часть  информации,  возвращаемой  данным  системным  вызовом также доступна через sysctl и
       через файлы /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}.
       
Чем отличается последовательность команд через ; и через && в bash? Например:
root@netology1:~# test -d /tmp/some_dir; echo Hi
Hi
root@netology1:~# test -d /tmp/some_dir && echo Hi
root@netology1:~#
Есть ли смысл использовать в bash &&, если применить set -e?
Ответ:
&& -  условный оператор, а ;  - разделитель последовательных команд

test -d /tmp/some_dir && echo Hi - в данном случае echo  отработает только если успешно отработает test

set -e - разорвет сессию при ненулевом значении исполняемых команд
в случае &&  вместе с set -e- наверное при ошибке , выполнение команд прекратиться. 

Из каких опций состоит режим bash set -euxo pipefail и почему его хорошо было бы использовать в сценариях?
Ответ:
-e прерывает выполнение при ошибке любой команды кроме последней
-x с помощью него bash печатает в стандартный вывод все команды перед их исполнением
-u благодаря ему оболочка проверяет инициализацию переменных в скрипте.
-o pipefail возвращает код возврата набора/последовательности команд, ненулевой при последней команды или 0 для успешного выполнения команд.

Используя -o stat для ps, определите, какой наиболее часто встречающийся статус у процессов в системе. В man ps ознакомьтесь 
(/PROCESS STATE CODES) что значат дополнительные к основной заглавной буквы статуса процессов. 
Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).

Самые частые 
S*(S,S+,Ss,Ssl,Ss+) - Процессы ожидающие завершения
I*(I,I<) - фоновые(бездействующие).
